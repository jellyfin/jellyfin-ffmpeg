--- FFmpeg.orig/libavfilter/vf_tonemapx.c
+++ FFmpeg/libavfilter/vf_tonemapx.c
@@ -89,6 +89,7 @@ typedef struct TonemapxContext {
     float *tonemap_lut;
     uint16_t *delin_lut;
     int in_yuv_off, out_yuv_off;
+    struct DoviMetadata *dovi;

     DECLARE_ALIGNED(16, int16_t, yuv2rgb_coeffs)[3][3][8];
     DECLARE_ALIGNED(16, int16_t, rgb2yuv_coeffs)[3][3][8];
@@ -113,6 +114,13 @@ static const enum AVPixelFormat out_pix_
     AV_PIX_FMT_P016,
 };

+static const double dovi_lms2rgb_matrix[3][3] =
+    {
+        { 3.06441879, -2.16597676,  0.10155818},
+        {-0.65612108,  1.78554118, -0.12943749},
+        { 0.01736321, -0.04725154,  1.03004253},
+    };
+
 static int out_format_is_supported(enum AVPixelFormat fmt)
 {
     int i;
@@ -383,6 +391,205 @@ static int compute_rgb_coeffs(TonemapxCo
     return 0;
 }

+inline static float dot(const float* x, const float* y, int len)
+{
+    int i;
+    float result = 0;
+    for (i = 0; i < len; i++) {
+        result += x[i] * y[i];
+    }
+    return result;
+}
+
+inline static float reshape_poly(float s, float* coeffs) {
+    return (coeffs[2] * s + coeffs[1]) * s + coeffs[0];
+}
+
+static float reshape_mmr(const float* sig, const float* coeffs, const struct ReshapeData *comp, int pivot_index) {
+    int min_order = 3, max_order = 1;
+    int order = (int)coeffs[3];
+    float s = coeffs[0];
+    float sigX[7] = {sig[0], sig[1], sig[2],
+                     sig[0] * sig[1], sig[0] * sig[2], sig[1] * sig[2], sig[0] * sig[1] * sig[2]};
+    min_order = FFMIN(min_order, comp->mmr_order[pivot_index]);
+    max_order = FFMAX(max_order, comp->mmr_order[pivot_index]);
+
+    s += dot(comp->mmr_coeffs[pivot_index][0], sigX, 7);
+
+    if (max_order >= 2 && (min_order >= 2 || order >= 2)) {
+        float sigX2[7] = {sig[0] * sig[0], sig[1] * sig[1], sig[2] * sig[2],
+                          sigX[0] * sigX[0], sigX[1] * sigX[1], sigX[2] * sigX[2], sigX[3] * sigX[3]};
+        s += dot(comp->mmr_coeffs[pivot_index][1], sigX2, 7);
+
+        if (max_order == 3 && (min_order == 3 || order >= 3)) {
+            float sigX3[7] = {sig[0] * sig[0] * sig[0], sig[1] * sig[1] * sig[1], sig[2] * sig[2] * sig[2],
+                              sigX2[0] * sigX[0], sigX2[1] * sigX[1], sigX2[2] * sigX[2], sigX2[3] * sigX[3]};
+            s += dot(comp->mmr_coeffs[pivot_index][2], sigX3, 7);
+        }
+    }
+
+    return s;
+}
+
+inline static void ycc2rgb(float* dest, float y, float cb, float cr, const double nonlinear[3][3], const float* ycc2rgb_offset)
+{
+    float offset1 = ycc2rgb_offset[0] * (float)nonlinear[0][0] + ycc2rgb_offset[1] * (float)nonlinear[0][1] + ycc2rgb_offset[2] * (float)nonlinear[0][2];
+    float offset2 = ycc2rgb_offset[0] * (float)nonlinear[1][0] + ycc2rgb_offset[1] * (float)nonlinear[1][1] + ycc2rgb_offset[2] * (float)nonlinear[1][2];
+    float offset3 = ycc2rgb_offset[0] * (float)nonlinear[2][0] + ycc2rgb_offset[1] * (float)nonlinear[2][1] + ycc2rgb_offset[2] * (float)nonlinear[2][2];
+
+    dest[0] = (y * (float)nonlinear[0][0] + cb * (float)nonlinear[0][1] + cr * (float)nonlinear[0][2]) - offset1;
+    dest[1] = (y * (float)nonlinear[1][0] + cb * (float)nonlinear[1][1] + cr * (float)nonlinear[1][2]) - offset2;
+    dest[2] = (y * (float)nonlinear[2][0] + cb * (float)nonlinear[2][1] + cr * (float)nonlinear[2][2]) - offset3;
+}
+
+// This implementation does not do the costly linearization and de-linearization for performance reasons
+// The output color accuracy will be affected due to this
+inline static void lms2rgb(float* dest, float l, float m, float s, const double linear[3][3])
+{
+    double lms2rgb_matrix[3][3];
+    ff_matrix_mul_3x3(lms2rgb_matrix, dovi_lms2rgb_matrix, linear);
+    dest[0] = l * (float)lms2rgb_matrix[0][0] + m * (float)lms2rgb_matrix[0][1] + s * (float)lms2rgb_matrix[0][2];
+    dest[1] = l * (float)lms2rgb_matrix[1][0] + m * (float)lms2rgb_matrix[1][1] + s * (float)lms2rgb_matrix[1][2];
+    dest[2] = l * (float)lms2rgb_matrix[2][0] + m * (float)lms2rgb_matrix[2][1] + s * (float)lms2rgb_matrix[2][2];
+}
+
+#define CLAMP(a, b, c) (FFMIN(FFMAX((a), (b)), (c)))
+static void reshape_dovi_yuv(float* dest, float* src, TonemapxContext *ctx)
+{
+    int i, k;
+    float s;
+    float coeffs[4] = {0, 0, 0, 0};
+
+    float sig_arr[3] = {CLAMP((src[0] - 2048.0f) / 28672.0f, 0.0f, 1.0f), CLAMP((src[1] - 2048.0f) / 28672.0f, 0.0f, 1.0f), CLAMP((src[2] - 2048.0f) / 28672.0f, 0.0f, 1.0f)};
+    for (i = 0; i < 3; i++) {
+        const struct ReshapeData *comp = &ctx->dovi->comp[i];
+        s = sig_arr[i];
+        if (comp->num_pivots >= 9 && s >= comp->pivots[7]) {
+            switch (comp->method[7]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[7][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[7];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[7];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 7);
+                    break;
+            }
+        } else if (comp->num_pivots >= 8 && s >= comp->pivots[6]) {
+            switch (comp->method[6]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[6][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[6];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[6];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 6);
+                    break;
+            }
+        } else if (comp->num_pivots >= 7 && s >= comp->pivots[5]) {
+            switch (comp->method[5]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[5][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[5];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[5];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 5);
+                    break;
+            }
+        } else if (comp->num_pivots >= 6 && s >= comp->pivots[4]) {
+            switch (comp->method[4]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[4][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[4];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[4];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 4);
+                    break;
+            }
+        } else if (comp->num_pivots >= 5 && s >= comp->pivots[3]) {
+            switch (comp->method[3]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[3][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[3];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[3];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 3);
+                    break;
+            }
+        } else if (comp->num_pivots >= 4 && s >= comp->pivots[2]) {
+            switch (comp->method[2]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[2][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[2];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[2];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 2);
+                    break;
+            }
+        } else if (comp->num_pivots >= 3 && s >= comp->pivots[1]) {
+            switch (comp->method[1]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[1][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[1];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[1];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 1);
+                    break;
+            }
+        } else {
+            switch (comp->method[0]) {
+                case 0: // polynomial
+                    coeffs[3] = 0.0f; // order=0 signals polynomial
+                    for (k = 0; k < 3; k++)
+                        coeffs[k] = comp->poly_coeffs[0][k];
+                    s = reshape_poly(s, coeffs);
+                    break;
+                case 1:
+                    coeffs[0] = comp->mmr_constant[0];
+                    coeffs[1] = (float)(2 * i);
+                    coeffs[3] = (float)comp->mmr_order[0];
+                    s = reshape_mmr(sig_arr, coeffs, comp, 0);
+                    break;
+            }
+        }
+        sig_arr[i] = CLAMP(s, comp->pivots[0], comp->pivots[comp->num_pivots-1]);
+    }
+    *dest = *sig_arr;
+}
+
 static void tonemap_int16(int16_t r_in, int16_t g_in, int16_t b_in,
                           int16_t *r_out, int16_t *g_out, int16_t *b_out,
                           float *lin_lut, float *tonemap_lut, uint16_t *delin_lut,
@@ -462,7 +669,8 @@ static void tonemap_frame_p016_p010_2_nv
                                            int srcdepth,
                                            int width,
                                            int height,
-                                           const struct TonemapIntParams *params)
+                                           const struct TonemapIntParams *params,
+                                           TonemapxContext *s)
 {
     const int in_depth = srcdepth;
     const int in_uv_offset = 128 << (in_depth - 8);
@@ -503,20 +711,58 @@ static void tonemap_frame_p016_p010_2_nv
             int u = (srcuv[x]     >> in_sh2) - in_uv_offset;
             int v = (srcuv[x + 1] >> in_sh2) - in_uv_offset;

-            r[0] = av_clip_int16((y00 * cy + crv * v + in_rnd) >> in_sh);
-            r[1] = av_clip_int16((y01 * cy + crv * v + in_rnd) >> in_sh);
-            r[2] = av_clip_int16((y10 * cy + crv * v + in_rnd) >> in_sh);
-            r[3] = av_clip_int16((y11 * cy + crv * v + in_rnd) >> in_sh);
-
-            g[0] = av_clip_int16((y00 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[1] = av_clip_int16((y01 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[2] = av_clip_int16((y10 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[3] = av_clip_int16((y11 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-
-            b[0] = av_clip_int16((y00 * cy + cbu * u + in_rnd) >> in_sh);
-            b[1] = av_clip_int16((y01 * cy + cbu * u + in_rnd) >> in_sh);
-            b[2] = av_clip_int16((y10 * cy + cbu * u + in_rnd) >> in_sh);
-            b[3] = av_clip_int16((y11 * cy + cbu * u + in_rnd) >> in_sh);
+            float yuv1[3], yuv2[3], yuv3[3], yuv4[3], chroma_sample[3];
+            float c1[3], c2[3], c3[3], c4[3];
+
+            yuv1[0] = y00;
+            yuv2[0] = y01;
+            yuv3[0] = y10;
+            yuv4[0] = y11;
+            yuv1[1] = yuv2[1] = yuv3[1] = yuv4[1] = u;
+            yuv1[2] = yuv2[2] = yuv3[2] = yuv4[2] = v;
+
+            reshape_dovi_yuv(yuv1, yuv1, s);
+            reshape_dovi_yuv(yuv2, yuv2, s);
+            reshape_dovi_yuv(yuv3, yuv3, s);
+            reshape_dovi_yuv(yuv4, yuv4, s);
+            ycc2rgb(c1, yuv1[0], yuv1[1], yuv1[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c2, yuv2[0], yuv2[1], yuv2[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c3, yuv3[0], yuv3[1], yuv3[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c4, yuv4[0], yuv4[1], yuv4[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            lms2rgb(c1, c1[0], c1[1], c1[2], s->dovi->linear);
+            lms2rgb(c2, c2[0], c2[1], c2[2], s->dovi->linear);
+            lms2rgb(c3, c3[0], c3[1], c3[2], s->dovi->linear);
+            lms2rgb(c4, c4[0], c4[1], c4[2], s->dovi->linear);
+
+            r[0] = av_clip_int16(c1[0] * 28672);
+            r[1] = av_clip_int16(c2[0] * 28672);
+            r[2] = av_clip_int16(c3[0] * 28672);
+            r[3] = av_clip_int16(c4[0] * 28672);
+
+            g[0] = av_clip_int16(c1[1] * 28672);
+            g[1] = av_clip_int16(c2[1] * 28672);
+            g[2] = av_clip_int16(c3[1] * 28672);
+            g[3] = av_clip_int16(c4[1] * 28672);
+
+            b[0] = av_clip_int16(c1[2] * 28672);
+            b[1] = av_clip_int16(c2[2] * 28672);
+            b[2] = av_clip_int16(c3[2] * 28672);
+            b[3] = av_clip_int16(c4[2] * 28672);
+
+//            r[0] = av_clip_int16((y00 * cy + crv * v + in_rnd) >> in_sh);
+//            r[1] = av_clip_int16((y01 * cy + crv * v + in_rnd) >> in_sh);
+//            r[2] = av_clip_int16((y10 * cy + crv * v + in_rnd) >> in_sh);
+//            r[3] = av_clip_int16((y11 * cy + crv * v + in_rnd) >> in_sh);
+//
+//            g[0] = av_clip_int16((y00 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[1] = av_clip_int16((y01 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[2] = av_clip_int16((y10 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[3] = av_clip_int16((y11 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//
+//            b[0] = av_clip_int16((y00 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[1] = av_clip_int16((y01 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[2] = av_clip_int16((y10 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[3] = av_clip_int16((y11 * cy + cbu * u + in_rnd) >> in_sh);

             tonemap_int16(r[0], g[0], b[0], &r[0], &g[0], &b[0],
                           params->lin_lut, params->tonemap_lut, params->delin_lut,
@@ -559,7 +805,8 @@ static void tonemap_frame_p016_p010_2_p0
                                                 int srcdepth,
                                                 int width,
                                                 int height,
-                                                const struct TonemapIntParams *params)
+                                                const struct TonemapIntParams *params,
+                                                TonemapxContext *s)
 {
     const int in_depth = srcdepth;
     const int in_uv_offset = 128 << (in_depth - 8);
@@ -600,20 +847,56 @@ static void tonemap_frame_p016_p010_2_p0
             int u = (srcuv[x]     >> in_sh2) - in_uv_offset;
             int v = (srcuv[x + 1] >> in_sh2) - in_uv_offset;

-            r[0] = av_clip_int16((y00 * cy + crv * v + in_rnd) >> in_sh);
-            r[1] = av_clip_int16((y01 * cy + crv * v + in_rnd) >> in_sh);
-            r[2] = av_clip_int16((y10 * cy + crv * v + in_rnd) >> in_sh);
-            r[3] = av_clip_int16((y11 * cy + crv * v + in_rnd) >> in_sh);
-
-            g[0] = av_clip_int16((y00 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[1] = av_clip_int16((y01 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[2] = av_clip_int16((y10 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-            g[3] = av_clip_int16((y11 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
-
-            b[0] = av_clip_int16((y00 * cy + cbu * u + in_rnd) >> in_sh);
-            b[1] = av_clip_int16((y01 * cy + cbu * u + in_rnd) >> in_sh);
-            b[2] = av_clip_int16((y10 * cy + cbu * u + in_rnd) >> in_sh);
-            b[3] = av_clip_int16((y11 * cy + cbu * u + in_rnd) >> in_sh);
+//            r[0] = av_clip_int16((y00 * cy + crv * v + in_rnd) >> in_sh);
+//            r[1] = av_clip_int16((y01 * cy + crv * v + in_rnd) >> in_sh);
+//            r[2] = av_clip_int16((y10 * cy + crv * v + in_rnd) >> in_sh);
+//            r[3] = av_clip_int16((y11 * cy + crv * v + in_rnd) >> in_sh);
+//
+//            g[0] = av_clip_int16((y00 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[1] = av_clip_int16((y01 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[2] = av_clip_int16((y10 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//            g[3] = av_clip_int16((y11 * cy + cgu * u + cgv * v + in_rnd) >> in_sh);
+//
+//            b[0] = av_clip_int16((y00 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[1] = av_clip_int16((y01 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[2] = av_clip_int16((y10 * cy + cbu * u + in_rnd) >> in_sh);
+//            b[3] = av_clip_int16((y11 * cy + cbu * u + in_rnd) >> in_sh);
+            float yuv1[3], yuv2[3], yuv3[3], yuv4[3], chroma_sample[3];
+            float c1[3], c2[3], c3[3], c4[3];
+            yuv1[0] = y00;
+            yuv2[0] = y01;
+            yuv3[0] = y10;
+            yuv4[0] = y11;
+            yuv1[1] = yuv2[1] = yuv3[1] = yuv4[1] = u;
+            yuv1[2] = yuv2[2] = yuv3[2] = yuv4[2] = v;
+
+            reshape_dovi_yuv(yuv1, yuv1, s);
+            reshape_dovi_yuv(yuv2, yuv2, s);
+            reshape_dovi_yuv(yuv3, yuv3, s);
+            reshape_dovi_yuv(yuv4, yuv4, s);
+            ycc2rgb(c1, yuv1[0], yuv1[1], yuv1[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c2, yuv2[0], yuv2[1], yuv2[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c3, yuv3[0], yuv3[1], yuv3[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            ycc2rgb(c4, yuv4[0], yuv4[1], yuv4[2], s->dovi->nonlinear, s->dovi->nonlinear_offset);
+            lms2rgb(c1, c1[0], c1[1], c1[2], s->dovi->linear);
+            lms2rgb(c2, c2[0], c2[1], c2[2], s->dovi->linear);
+            lms2rgb(c3, c3[0], c3[1], c3[2], s->dovi->linear);
+            lms2rgb(c4, c4[0], c4[1], c4[2], s->dovi->linear);
+
+            r[0] = av_clip_int16(c1[0] * 28672);
+            r[1] = av_clip_int16(c2[0] * 28672);
+            r[2] = av_clip_int16(c3[0] * 28672);
+            r[3] = av_clip_int16(c4[0] * 28672);
+
+            g[0] = av_clip_int16(c1[1] * 28672);
+            g[1] = av_clip_int16(c2[1] * 28672);
+            g[2] = av_clip_int16(c3[1] * 28672);
+            g[3] = av_clip_int16(c4[1] * 28672);
+
+            b[0] = av_clip_int16(c1[2] * 28672);
+            b[1] = av_clip_int16(c2[2] * 28672);
+            b[2] = av_clip_int16(c3[2] * 28672);
+            b[3] = av_clip_int16(c4[2] * 28672);

             tonemap_int16(r[0], g[0], b[0], &r[0], &g[0], &b[0],
                           params->lin_lut, params->tonemap_lut, params->delin_lut,
@@ -685,7 +968,7 @@ static int filter_slice(AVFilterContext
                                        out->linesize, in->linesize,
                                        odesc->comp[0].depth, desc->comp[0].depth,
                                        out->width, slice_end - slice_start,
-                                       &params);
+                                       &params, s);
     } else {
         tonemap_frame_p016_p010_2_p016_p010(out->data[0] + out->linesize[0] * slice_start,
                                             out->data[1] + out->linesize[1] * AV_CEIL_RSHIFT(slice_start, desc->log2_chroma_h),
@@ -694,7 +977,7 @@ static int filter_slice(AVFilterContext
                                             out->linesize, in->linesize,
                                             odesc->comp[0].depth, desc->comp[0].depth,
                                             out->width, slice_end - slice_start,
-                                            &params);
+                                            &params, s);
     }

     return 0;
@@ -712,6 +995,7 @@ static int filter_frame(AVFilterLink *li
     double peak = s->peak;
     const AVLumaCoefficients *coeffs;
     ThreadData td;
+    AVFrameSideData *dovi_sd = av_frame_get_side_data(in, AV_FRAME_DATA_DOVI_METADATA);

     desc = av_pix_fmt_desc_get(link->format);
     odesc = av_pix_fmt_desc_get(outlink->format);
@@ -781,6 +1065,23 @@ static int filter_frame(AVFilterLink *li
             goto fail;
     }

+    if (dovi_sd) {
+        const AVDOVIMetadata *metadata = (AVDOVIMetadata *) dovi_sd->data;
+        const AVDOVIRpuDataHeader *rpu = av_dovi_get_header(metadata);
+        // only map dovi rpus that don't require an EL
+        if (rpu->disable_residual_flag) {
+            struct DoviMetadata *dovi = av_malloc(sizeof(*dovi));
+            s->dovi = dovi;
+            if (!s->dovi)
+                goto fail;
+
+            ff_map_dovi_metadata(s->dovi, metadata);
+//            ctx->trc_in = AVCOL_TRC_SMPTE2084;
+//            ctx->colorspace_in = AVCOL_SPC_UNSPECIFIED;
+//            ctx->primaries_in = AVCOL_PRI_BT2020;
+        }
+    }
+
     /* do the tonemap */
     td.in    = in;
     td.out   = out;
